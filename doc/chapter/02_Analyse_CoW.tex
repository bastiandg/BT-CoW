\chapter{Analyse Copy-on-Write}
Für das Erstellen mehrerer gleichartiger Virtueller Maschinen benötigt man mehrere Virtuelle Festplatten. Das kann man auf herkömmliche Art und Weise lösen, in dem ein vorhandenes Festplattenimage n mal kopiert wird. Durch das häufige Kopieren entstehen allerdings große Mengen an Daten. Außerdem benötigt es viel Zeit Festplattenimages zu kopieren. Um diesen beiden Problemen entgegen zu wirken gibt es Copy-on-Write. Wie in Abbildung \ref{pic:cow} zu sehen ist, wird bei Copy-on-Write nicht das gesamte Image kopiert. Es werden in dem Copy-on-Write-Image nur die Veränderungen zu dem so genannten Master- oder Quellimage gespeichert. Für die Platzersparnis werden Sparse-Dateien genutzt welche im Folgenden erklärt werden. Außerdem werden die unterschiedlichen Verfahren zur Verwendung von Copy-on-Write erläutert und analysiert.

\bild{copyonwrite}{Copy-on-Write}{pic:cow}{420px}

\section{Sparse-Dateien}
Eine Sparse-Datei ist eine Datei, die nicht vom Anfang bis zum Ende beschrieben ist. Sie enthält also Lücken. Um Speicherplatz zu sparen, werden diese Lücken bei Sparse-Dateien nicht auf den Datenträger geschrieben. Die Abbildung \ref{pic:sparse} zeigt, dass der tatsächlich benutzte Speicherplatz auf der Festplatte weitaus geringer sein kann als die eigentliche Dateigröße. Eine Sparse-Datei ist kein eigenes Imageformat sondern eine Optimierungsstrategie. Sie verhilft Copy-on-Write-Images zu einer großen Platzersparnis. In Imageformaten wie qcow2 oder vhd ist die Optimierungsstrategie ein fester Bestandteil. \cite{sparse}

\bild{Sparse}{Sparse-Datei}{pic:sparse}{420px}

\section{qcow2}
Das Imageformat qcow2 ist im Rahmen des qemu Projekts entwickelt wurde. Es ist der Nachfolger des ebenfalls aus dem qemu Projekt stammenden Formats qcow. \cite{qcowmarkmc} \cite{qemuwiki}

\textbf{Vorteile}
\begin{itemize}
 \item einfache Einrichtung
\end{itemize}

\textbf{Nachteile}
\begin{itemize}
 \item Kompatibilitätsprobleme mit Xen und anderen offenen Virtualisierungstechniken (z.B. VirtualBox)
\end{itemize}

\section{vhd}
Das Format vhd ist von Conectix und Microsoft entwickelt worden. Die Spezifikation des Imageformats wurde von Microsoft im Zuge des ``Microsoft Open Specification Promise'' freigegeben. Seit der Freigabe der Spezifikation bieten einige Open Source Virtualisierungslösungen wie qemu, Xen oder VirtualBox die Möglichkeit dieses Format zu verwenden. \cite{msosp} \cite{vhdspec} %\gls{test}

\textbf{Vorteile}
\begin{itemize}
 \item einfache Einrichtung
\end{itemize}

\textbf{Nachteile}
\begin{itemize}
 \item Weiterentwicklung ist fragwürdig
 \item Verwendung von Copy-on-Write mit KVM nicht möglich
\end{itemize}

\section{dm-snapshots}
Die dm-snapshots sind eine Funktion des Device Mappers. Device Mapper ist ein Treiber im Linux-Kernel. Er erstellt virtuelle Gerätedateien, die mit bestimmten Features wie zum Beispiel Verschlüsselung ausgestattet sind. Bei dm-snapshots wird eine solche virtuelle Gerätedatei erstellt. Sie wird aus zwei anderen Gerätedateien zusammengesetzt. Die erste Gerätedatei ist der Ausgangspunkt, wenn an daran Änderungen vorgenommen werden, werden sie als Differenz in der zweiten Gerätedatei gespeichert. Dm-snapshots benötigen keine Unterstützung der Virtualisierungstechnik, da sie für diese nicht von physikalischen Festplattenpartitionen unterscheidbar sind. Dieses ist nicht nur ein Vorteil, sondern zugleich auch ein Nachteil. Es muss immer vor dem Starten einer virtuellen Maschine das Copy-on-Write-Image und das Masterimage zu einer Gerätedatei verbunden werden. \cite{dmmbroz} \cite{dmkerneldoc}

\textbf{Vorteile}
\begin{itemize}
 \item hohes Entwicklungsstadium
 \item sichere Weiterentwicklung
 \item unabhängig von Virtualisierungstechnik
\end{itemize}

\textbf{Nachteile}
\begin{itemize}
 \item Aufwendige Einrichtung
 \item erfordert zusätzlichen Programmstart vor dem VM-Start
\end{itemize}

\section{LVM-Snapshots}
LVM-Snapshots sind ein Teil des Logical Volume Managers. LVM ist eine Software-Schicht die über den eigentlichen Hardware-Festplatten einzuordnen ist. Es basiert auf Device Mapper. LVM ermöglicht das Anlegen von virtuelle Partitionen (logical volumes). Diese können sich über mehrere Festplatten-Partitionen erstrecken und Funktionen wie Copy-on-Write bereitstellen. \cite{lvmhowto} \cite{lvmselflinux} \cite{lvmsource}

\textbf{Vorteile}
\begin{itemize}
 \item hohes Entwicklungsstadium
 \item sichere Weiterentwicklung
 \item unabhängig von Virtualisierungstechnik
\end{itemize}

\textbf{Nachteile}
\begin{itemize}
 \item Aufwendige Einrichtung
% \item Migration schwierig
 \item Live-Migration nicht möglich
 \item Nutzung von Sparse-Dateien schwer umsetzbar
\end{itemize}

\section{Benchmarks}
Ein wichtiger Punkt für die Entscheidung welche Copy-on-Write Implementierung optimal ist, ist die Lese- und Schreibgeschwindigkeit. Hierbei gibt es zwei Zugriffsarten, einmal den sequentiellen Zugriff und den wahlfreien oder auch zufälligen Zugriff. Die Testergebnisse werden in diesem Kapitel zusammenfassend aufgeführt. Die kompletten Testergebnisse befinden sich im Anhang.

\subsection{Testbedingungen}
Das Hostsystem für die Performance-Tests hat einen AMD Athlon II X2 250 Prozessor und 4 GiB RAM. Als Betriebsystem kommt ein 64 bit Debian testing zum Einsatz. Bei den KVM-Tests ist 2.6.32-5-amd64 der eingesetzte Kernel, bei Xen ist es 2.6.32-5-xen-amd64.

Während der Performance-Tests laufen neben der Virtuellen Maschine auf dem Hostsystem keine anderen aktiven Programme, die das Ergebnis verfälschen könnten. Als Referenz zu den Copy-on-Write-Techniken werden jeweils eine echte Festplattenpartition und eine Sparse-Datei verwendet. Zum Testen der Performance werden IOzone und Bonnie++ eingesetzt.

\textbf{IOzone} \\
IOzone ist ein Tool mit dem in einer Reihe von unterschiedlichen Tests die Lese- und Schreib-Geschwindigkeit überprüft werden kann. Es wird hier zur Überprüfung der sequentiellen Lese- und Schreibgeschwindigkeit verwendet.

\textbf{Bonnie++} \\
Bonnie++ dient wie IOzone als Tool zum Testen von Festplatten. Es wird hier zur Überprüfung der sequentiellen Lese- und Schreibgeschwindigkeit sowie zum Testen des wahlfreien Zugriffs verwendet.

\subsection{Testergebnisse}
Es gibt bei den Testergebnissen keinen klaren Gewinner oder Verlierer. Im Großen und Ganzen fallen bei den Ergebnissen unter den einzelnen Copy-on-Write Verfahren keine bemerkenswerten Unterschiede auf.

\begin{comment} Bei dem Iozone-Test wurden Dateigrößen von 512 MB, 2 GB, 4 Gb und 8 GB verwendet. Für die Entscheidungsfindung wird jedoch nur der Test mit 8 GB Dateigröße herangezogen. \end{comment}

\bild{Iozone-kvm-8gb}{Iozone-kvm-8gb}{pic:iozonekvm}{420px}
Die Abbildung \ref{pic:iozonekvm} zeigt, dass mit KVM qcow2 gegenüber den anderen Copy-on-Write-Techniken einen Geschwindigkeitsvorteil beim sequentiellen Lesen und Schreiben hat. LVM-Snapshots und dm-snapshots liegen hingegen ungefähr gleich auf.

\bild{bonnie-kvm-random-seek}{bonnie-kvm-random-seek}{pic:bonniekvm}{420px}
Abbildung \ref{pic:bonniekvm} ist zu entnehmen, dass qcow2 wie auch bei den sequentiellen Tests vor LVM-Snapshots und dm-snapshots liegt. Der Unterschied zu der echten Festplattenpartition ist in beiden Tests sehr gering. Die guten Werte von qcow2 sowohl beim sequentiellen als auch beim zufälligem Zugriff auf die Festplatte, hängen mit der direkten Integration in KVM zusammen.

In Xen schneiden die dm-snapshots besser ab als LVM-Snapshots und vhd beim sequentiellen Lesen und Schreiben, wie in Abbildung \ref{pic:iozonexen} zu sehen ist. 
\bild{Iozone-xen-8gb}{Iozone-xen-8gb}{pic:iozonexen}{420px}

Beim zufälligen Zugriff auf die Festplatte ist unter Xen vhd abgeschlagen hinter LVM-Snapshots und dm-snapshots. Diese sind ungefähr gleichauf und liegen nicht weit hinter dem Sparse-Image und der Festplattenpartition (Abbildung \ref{pic:bonniexen}). Das mittelmäßige Abschneiden des Imageformats vhd verwundert, da Citrix, die treibende Kraft der Xen Weiterentwicklung, eine optimierte vhd-Unterstützung entwickelt hat. \cite{citrixvhd}
\bild{bonnie-xen-random-seek}{bonnie-xen-random-seek}{pic:bonniexen}{420px}

Die Testergebnisse zeigen, dass es Geschwindigkeitsunterschiede zwischen den Copy-on-Write-Technniken gibt. Diese Unterschiede in der Geschwindigkeit sind aber nicht so gravierend, dass man einzelne Copy-on-Write-Lösungen aufgrund der Performance-Tests kategorisch ausschließen müsste. Dennoch sind besonders die Vorteile von qcow2 in Verbindung mit KVM zu erwähnen. Für Xen gibt es kein Image-Format, dass ähnliche Testergebnisse wie qcow2 in Verbindung mit KVM vorweisen kann. 

\section{Fazit}
Aufgrund des unterschiedlichen Verhaltens der Copy-on-Write-Techniken mit KVM und Xen, wird auch für die beiden Virtualisierungslösungen ein jeweiliges Fazit gezogen.

\subsection{KVM}
Unter KVM gibt es die Alternativen dm-snapshots LVM-Snapshots oder qcow2. Das von Microsoft entwickelte vhd kommt nicht in Frage. KVM unterstützt zwar das vhd-Format, jedoch nicht die Copy-on-Write-Funktion des Formats. 

Die effizienteste Lösung für Copy-on-Write mit KVM ist qcow2. Dafür gibt es mehrere Gründe. Das qcow2-Format ist Teil des qemu-Projekts und damit sehr gut in dem darauf basierendem KVM integriert. Durch die gute Integration werden sehr gute Performance-Werte erreicht. Außerdem lässt es sich im Gegensatz zu dm-snapshots und LVM-Snapshots sehr leicht einrichten.

\subsection{Xen}
Die für Xen zur Verfügung stehenden Copy-on-Write-Formate sind dm-snapshots, LVM-snapshots und vhd. Xen ünterstützte in einigen vergangenen Versionen qcow2, diese Unterstützung ist jedoch nicht in der aktuellen Version enthalten (Version 4.0.1). \cite{qcow2support}

Für Xen ist die beste Copy-on-Write-Lösung vhd. Es ist zwar laut der Performance-Tests nicht die schnellste Lösung, hat aber wesentliche Vorteile gegenüber dm-snapshots und LVM-Snapshots. Es werden keine Änderungen am Xen-Quelltext benötigt, wie es bei dm-snapshots der Fall ist. Die Funktion der Live-Migration ist mit vhd leichter zu realisieren als mit LVM-Snapshots und dm-snapshots. Die in dieser Arbeit verwendete Lösung ist vhd. Falls Xen in den nächsten Versionen wieder qcow2 unterstützt, sollte jedoch die Verwendung von qcow2 auch unter Xen geprüft werden. \cite{racecondition}